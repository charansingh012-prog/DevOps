=========================
Jinja2 Templates in Ansible  
===========================

Jinja2 is a templating engine used in Ansible for dynamically generating files, configurations, and scripts based on variables.

The Jinja2 templating engine is quite powerful and widely used with other frameworks and applications such as Flask and Django.


Jinja2 is a templating engine used in Ansible for dynamically generating files, configurations, and scripts based on variables.

ðŸ”¹ Example: Nginx Configuration Template
------------------------------------------

mkdir templates
cd templates

ðŸ“Œ Create a Jinja2 Template (templates/nginx.conf.j2)

vi nginx.conf.j2

server {
    listen {{ nginx_port }};
    server_name {{ server_name }};

    location / {
         root {{ web_root }};
        index index.html;
    }
}

This template uses variables ({{ variable_name }}) that will be replaced dynamically.


vi nginx.yml

---
- name: Deploy Nginx Config using Jinja2
  hosts: all
  become: yes
  vars:
    nginx_port: 80
    server_name: mywebsite.com
    web_root: /var/www/html

  tasks:
    - name: Enable Nginx Repo
      command: amazon-linux-extras enable nginx1

    - name: Install Nginx
      yum:
        name: nginx
        state: present

    - name: Copy Nginx Config with Template
      template:
        src: templates/nginx.conf.j2
        dest: /etc/nginx/nginx.conf


ansible-playbook nginx.yml

=========================
Jinja2 HTTPD another Example
==========================

Below is a Jinja2 template for an Apache (httpd.conf) configuration file. It dynamically sets port, document root, and virtual hosts using Ansible variables.

ðŸ”¹ Step 1: Create Jinja2 Template (templates/httpd.conf.j2)
----------------------------------------------------------

mkdir templates

# Apache HTTPD Configuration File

vi httpd.conf.j2

Listen {{ http_port }}

<VirtualHost *:{{ http_port }}>
    ServerName {{ server_name }}
    DocumentRoot {{ document_root }}

    <Directory "{{ document_root }}">
        AllowOverride None
        Require all granted
    </Directory>

    ErrorLog /var/log/httpd/{{ server_name }}_error.log
    CustomLog /var/log/httpd/{{ server_name }}_access.log combined
</VirtualHost>


Variables Used:
--------------

http_port â†’ Defines the listening port.
server_name â†’ Sets the domain name.
document_root â†’ Defines the root directory for website files.

ðŸ”¹ Step 2: Ansible Playbook Using the Template
-----------------------------------------------

Create a playbook (apache_setup.yml) to deploy the template:


---
- name: Configure Apache HTTPD with Jinja2
  hosts: all
  become: yes
  vars:
    http_port: 80
    server_name: example.com
    document_root: /var/www/html

  tasks:
    - name: Install Apache (httpd)
      yum:
        name: httpd
        state: present

    - name: Deploy Apache Configuration
      template:
        src: templates/httpd.conf.j2
        dest: /etc/httpd/conf/httpd.conf


What This Playbook Does:
-------------------------

Installs Apache (httpd).
Copies the Jinja2 template (httpd.conf.j2) to /etc/httpd/conf/httpd.conf.
Notifies the handler to restart Apache when the config changes.



================================

Ansible Strategies  

================================

Linear = Execute tasks one by one, all task will execute on one node then only go to second node
FREE = Execute all tasks parallelly on all nodes, it will not wait for tasks
Rolling = see in internet

âœ… linear (default) = Default execution (wait for all hosts per task)
                      Moves to the next task only after all hosts complete the current task.
   
âœ… free = Fastest execution (tasks don't wait for each other)    
           Each host executes tasks as fast as it can, without waiting for others
       Faster execution but tasks can finish out of order.

âœ… host_pinned  = Host-by-host execution (one host at a time)    

âœ… debug = Debugging playbooks (step-by-step execution)    

âœ… custom strategy = Custom execution needs

---
- name: Strategies
  hosts: all
  strategy: Linear
  tasks:
    - name: Installing Apache
      yum: name=httpd state=present

=============================
PIP - its a package manager used to install libs/modules
=============================

Python : pip  (if you want to install numpy and pandas in python use pip)

using pip module install NumPy and Pandas
----------------------------------------
- name: Playbook using pip
  hosts: all
  tasks:
    - name: install pip module
      yum: name=pip state=present

    - name: installing Numpy
      pip: name=NumPy state=present

    - name: installing Pandas
      pip: name=Pandas state=present


=====================
Ansible ROLES
====================

Ansible roles help organize and structure your playbooks by breaking them into reusable components. They simplify automation by grouping related tasks, handlers, variables, and templates in a standardized directory format.


Ansible Roles used to divide playbook into directory structure.

Ansible roles are reusable.


ðŸ”¹ Why Use Roles?
âœ… Modular & Reusable: Write once, use multiple times.
âœ… Scalable: Easily manage configurations across many systems.
âœ… Organized: Avoid large, cluttered playbooks.

ðŸ”¹ Role Directory Structure
When you create a role, Ansible generates a standard folder structure:



yum install tree -y ---> to see folders in tree structure

Manual method of creating Ansible Roles
--------------------------------------

mkdir playbooks
cd playbooks

mkdir -p roles/pkgs/tasks

mkdir -p roles/users/tasks

tree

mkdir -p roles/webserver/tasks

tree

vi roles/pkgs/tasks/main.yml

- name: install pkgs
  yum: name={{item}} state=present
  loop:
    - git
    - java-1.8.0-openjdk
    - tree
    - docker
    - maven


vi roles/users/tasks/main.yml

- name: create users
  user: name={{item}} state=present
  with_items:
    - luckyy
    - imthiaz
    - siva
    - rajesh
    - pavan


vi roles/webserver/tasks/main.yml

- name: install webserver
  yum: name=httpd state=present

- name: starting httpd
  service: name=httpd state=started

--> tree

 --> create a new master yml and mention which role you want to execute

vi master.yml

---
- name: ROLE PLAYBOOK
  hosts: all
  roles:
    - pkgs
    - user
    - webserver

ansible-playbook master.yml


Now uninstall all

sed -i 's/present/absent/g' roles/pkgs/tasks/main.yml

Above command need to do one by one for all yml files, use exec command

find . -type f -exec sed -i 's/present/absent/g' {} \;


find . =     Searches in the current directory (.) and all subdirectories.
-type f =     Finds only files (not directories).
-exec ... \;    Executes a command (sed) on each file found.
sed -i 's/present/absent/g' =     Uses sed (stream editor) to replace "present" with "absent" globally (g) within each file.
{} =        A placeholder for each file found by find.
\; =        Ends the -exec command.

now run the playbook

ansible-playbook master.yml


=========================
Ansible-Galaxy -    
=========================

Ansible Galaxy is a repository for sharing pre-built Ansible roles. You can download, install, and use roles to speed up automation.

Use ansible galaxy website and use the roles locally by copying the command like search for tomcat and run the command

https://galaxy.ansible.com/ui/standalone/roles/

search for tomcat and copy paste the command ansible-galaxy role install criecm.tomcat

ansible-galaxy role install criecm.tomcat

By default it will install in /root/.ansible/roles

If you want to change the path , edit ansible.cfg and uncomment

vi /etc/ansible/ansible.cfg
role_path = /etc/ansible/roles

It will create so many roles itself and we can use the roles

if we want to create roles, use either mkdir manually or init command (it will create folder structure)

cd /etc/ansible/roles

ansible-galaxy init Reyaz

tree

.
â””â”€â”€ reyaz
    â”œâ”€â”€ defaults
    â”‚   â””â”€â”€ main.yml
    â”œâ”€â”€ files
    â”œâ”€â”€ handlers
    â”‚   â””â”€â”€ main.yml
    â”œâ”€â”€ meta
    â”‚   â””â”€â”€ main.yml
    â”œâ”€â”€ README.md
    â”œâ”€â”€ tasks
    â”‚   â””â”€â”€ main.yml
    â”œâ”€â”€ templates
    â”œâ”€â”€ tests
    â”‚   â”œâ”€â”€ inventory
    â”‚   â””â”€â”€ test.yml
    â””â”€â”€ vars
        â””â”€â”€ main.yml




examples

  ansible-galaxy search tomcat
  ansible-galaxy install amtega.tomcat


==========================
Ansible - VAULT - ENCRYPTION
=========================

Ansible Vault allows you to encrypt and secure sensitive data like passwords, API keys, SSH keys, and confidential variables within playbooks.

Ansible vault is used to encrypt the data.

In real time to keep our sensitive data protectively we use vault.

Technique: AES256

we can restrict the playbooks to run.

-------------------------------------------------

ansible-vault create secret.txt  --> to create a vault

give password
db_password: mysecurepassword
api_key: "12345-abcde-67890"


cat secret.txt

Encrypted

ansible-vault edit secret.txt   --> to edit a vault
give password
change something

cat secret.txt

ansible-vault rekey secret.txt   --> to change the password

ansible-vault decrypt secret.txt --> to decrypt and see the content

cat secret.txt

ansible-vault encrypt secret.txt --> to encrypt again

cat secret.txt

ansible-vault view secret.txt  --> to view the content without decryption

======================================
ASYNCHRONOUS & POLLING ACTIONS:
========================================

By default, Ansible runs tasks synchronously, meaning it waits for each task to finish before moving to the next one.
However, for long-running tasks (e.g., software installation, backups, database updates), you can use asynchronous execution with polling to avoid timeouts


For every task in  ansible we can set time limit

If the task is not performed in that time limit ansible will stop playbook execution

This is called as asynchronous and polling.

---
- name: Async and poll playbook
  hosts: all
  ignore_errors: yes
  tasks:
    - name: sleeping
      command: sleep 30
      async: 20
      poll: 10
    - name: install git
      yum: name=git state=present


async: time we set for task to complete
poll: it will check if task is completed or not for every 10 sec

=======================================================
Using Multiple Playbooks in a Single Playbook in Ansible
=======================================================

Method 1: Using import_playbook (Recommended)
-----------------------------------------

---
- import_playbook: setup_webserver.yml
- import_playbook: deploy_application.yml
- import_playbook: configure_firewall.yml

Method 2: Using include_tasks (For Tasks Inside a Playbook)
-----------------------------------------------------------

---
- name: Setup Server
  hosts: all
  become: yes

  tasks:
    - include_tasks: install_nginx.yml
    - include_tasks: configure_firewall.yml




===================
MINI PROJECT - How to setup Front end code
====================

WEB SERVER : TO SHOW THE APP : httpd  : 80  : /var/www/html
frontend code
APP SERVER : TO USE THE APP : Tomcat  : 8080  : tomcat/webapps
frontend code + backend code

vi miniproject.yml
---
- name: Mini Project
  hosts: all
  tasks:
    - name: installing httpd
      yum: name=httpd state=present

    - name: starting httpd
      service: name=httpd state=started

    - name: installing git
      yum: name=git state=present

    - name: checkout
      git:
        repo: https://github.com/ReyazShaik/amazon.git
        dest: /var/www/html


copy paste the ip in browser

TO encrypt playbook


ansible-vault create miniproject1.yml

now ansible-playbook miniproject1.yml   --> you cannot run the playbook in encrypt mode

decrypt the playbook and run if you want

ansible-vault decrypt miniproject1.yml

ansible-playbook miniproject1.yml